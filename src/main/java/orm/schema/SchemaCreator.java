package orm.schema;

import orm.annotations.ManyToMany;
import orm.annotations.OneToOne;
import orm.session.ConnectionPool;
import orm.session.Executor;
import orm.sql.CommandType;
import orm.sql.Query;
import orm.sql.QueryBuilder;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class SchemaCreator {
    private List<Query> queries = new ArrayList<>();
    private final Executor executor;
    private ClassFinder finder = new ClassFinder();
    private ClassScanner scanner = new ClassScanner();
    private Set<Class> entityClasses;

    private final Set<String> associationTables = new HashSet<>();

    public SchemaCreator(ConnectionPool connectionPool) {
        this.executor = new Executor(connectionPool);
    }

    public void createSchema() throws Exception {
        entityClasses = finder.findEntityClasses();
        addQueryForIdTable();
        addQueriesToCreateTables();
        addQueriesForOneToOnes();
        //przy One-to-Many mamy fk w innej tabeli, więc nie potrzeba zapytań
        addQueriesForManyToOnes();
        addQueriesForManyToManys();

        System.out.println("Queries generated by SchemaCreator:");
        queries.forEach(System.out::println);
        System.out.println();

        // przy strategii Class Table Inheritance nie potrzeba tu dodatkowego kodu do obsługi dziedziczenia
        executor.execute(queries);
    }

    public void addQueryForIdTable(){
        queries.addAll(List.of(
                new QueryBuilder(CommandType.CREATE).addTable("id").addColumn("id", "INT").build(),
                new Query("INSERT INTO id (id) VALUES(1);")
        ));
    }

    public void addQueriesToCreateTables(){
        for (Class clazz: entityClasses){
            List<Field> columns = scanner.getColumns(clazz);
            QueryBuilder qb = new QueryBuilder(CommandType.CREATE).addTable(clazz);
            qb.addId();
            columns.forEach(qb::addColumn);
            queries.add(qb.build());
        }
    }
    public void addQueriesForOneToOnes(){
        for (Class clazz: entityClasses){
            QueryBuilder qb = new QueryBuilder(CommandType.ALTER).addTable(clazz);
            List<Field> fields = scanner.getOneToOneFields(clazz)
                    .stream()
                    .filter(f -> f.getAnnotation(OneToOne.class).foreignKeyInThisTable())
                    .toList();
            if (fields.size() > 0) {
                fields.forEach(qb::addForeignKey);
                queries.add(qb.build());
            }
        }
    }
    public void addQueriesForManyToOnes(){
        for (Class clazz: entityClasses){
            QueryBuilder qb = new QueryBuilder(CommandType.ALTER).addTable(clazz);
            List<Field> fields = scanner.getManyToOneFields(clazz);
            if (fields.size() > 0) {
                fields.forEach(qb::addForeignKey);
                queries.add(qb.build());
            }
        }
    }
    public void addQueriesForManyToManys(){
        for (Class clazz: entityClasses){
            for (Field field: scanner.getManyToManyFields(clazz)){
                String associationTable = field.getAnnotation(ManyToMany.class).tableName();
                QueryBuilder qb = new QueryBuilder();
                if (! associationTables.contains(associationTable)){
                    qb.setCommandType(CommandType.CREATE);
                    associationTables.add(associationTable);
                } else{
                    qb.setCommandType(CommandType.ALTER);
                }
                qb.addTable(associationTable).addForeignKey(field);
                queries.add(qb.build());
            }
        }

    }

}
